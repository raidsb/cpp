WHAT IS cMAKE?
--------------
my summary: an open-source build and configuration tool for managing the build process 
of c++ software projects build system and project configuration tool used for managing 
the build process of C and C++ software projects across different platforms and build 
environments
files should be named "CMakeLists.txt" to be recognized by VS and also the tool I think.

Project Main CMAKE file instruction:
------------------------------------
[1] "cmake_minimum_required(VERSION 3.15)"
The line cmake_minimum_required(VERSION 3.15) is a CMake command that specifies the minimum version of 
CMake required to configure and build a CMake project. 
This command is typically placed near the beginning of a CMakeLists.txt file, which is used to define 
how a CMake project should be built. 

In this specific case, the command sets the minimum required CMake version to 3.15. This means that 
any system running CMake 3.15 or a more recent version can be used to configure and build the project. 
If a system has an older version of CMake installed (e.g., 3.14 or earlier), attempting to configure 
the project with that older version will result in a CMake error, indicating that a more recent version
of CMake is required. 

Specifying the minimum required CMake version is essential because CMake evolves over time, and newer 
versions may introduce features, improvements, and changes to the CMake language that are not compatible 
with older versions. By setting a minimum required version, you ensure that users of your CMake project 
have a compatible version of CMake installed. 

Developers typically choose a minimum required version based on the features and capabilities they intend 
to use in their CMake project. 
Using a more recent version of CMake allows you to leverage the latest enhancements and features, 
but it may limit compatibility with older CMake installations. 

In practice, when you distribute a CMake-based project, you should document the minimum required CMake 
version so that users know which version to install or upgrade to if necessary. 
This helps ensure a smooth and error-free configuration and build process for your project. "

[2] Project information 
"project(MyCppProject
		VERSION 0.0.1 
		DESCRIPTION "My Cpp project"
		LANGUAGES CXX)"
This line declares a CMake project named "MyCppProject."
The VERSION keyword is used to specify the project's version number (in this case, version 0.0.1).
The DESCRIPTION keyword provides a brief description of the project.
The LANGUAGES keyword specifies the programming languages used in the project (in this case, C++ - denoted by CXX).
This code sets up the basic project metadata, including its name, version, description, and the primary programming language.

[3] some configurations
"if (CMAKE_PROJECT_NAME STREQUAL PROJECT_NAME)
	set (MODERN_CMAKE_BUILD_TESTING ON)
	set (CMAKE_CXX_EXTENSIONS OFF)
	set (CMAKE_EXPORT_COMPILE_COMMANDS ON)

	# Support folders in IDEs.
	set_property(GLOBAL PROPERTY USE_FOLDERS ON)
endif 
"
The code snippet you've provided is a portion of a CMake configuration script. 
Let's break down what each part does:

	1. if (CMAKE_PROJECT_NAME STREQUAL PROJECT_NAME):
	This line checks if the CMake variable CMAKE_PROJECT_NAME is equal to the variable PROJECT_NAME.
	CMAKE_PROJECT_NAME is a built-in CMake variable that represents the name of the current project 
	being configured. PROJECT_NAME is typically a variable that developers can set to specify the name of their project.


	2. set (MODERN_CMAKE_BUILD_TESTING ON): If the condition in the if statement is true, this line sets 
	the variable MODERN_CMAKE_BUILD_TESTING to ON. MODERN_CMAKE_BUILD_TESTING is likely a variable used 
	to control whether testing is enabled for the project. Enabling testing means that CMake will generate 
	build targets for running tests if there are any defined in the project.

	3. set (CMAKE_CXX_EXTENSIONS OFF):
	This line sets the variable CMAKE_CXX_EXTENSIONS to OFF.
	CMAKE_CXX_EXTENSIONS controls whether the compiler should enable language extensions. 
	Setting it to OFF means that language extensions are disabled.

	4. set (CMAKE_EXPORT_COMPILE_COMMANDS ON):
	This line sets the variable CMAKE_EXPORT_COMPILE_COMMANDS to ON.
	CMAKE_EXPORT_COMPILE_COMMANDS controls whether CMake generates a compile_commands.json file, 
	which is used by some IDEs for code navigation and completion.

	5. set_property(GLOBAL PROPERTY USE_FOLDERS ON):
	This line sets a global property to enable the use of folders in IDEs.
	When USE_FOLDERS is set to ON, it organizes targets and source files into folders within integrated 
	development environments (IDEs) for better project structure and organization.

The conditional check at the beginning ensures that these settings are applied only when configuring 
the main project (i.e., when the CMake project name matches the specified project name). 
These settings are often used to configure the build environment, compiler options, 
and IDE integration for a CMake-based project.

[4] Turn on warnings for GCC.
"if (CMAKE_COMPILER_IS_GNUCC) 
	add_compile_options(-Wall -Wextra -pedantic -Werror)
endif"

	-Wall: Enables a set of commonly used warning flags, such as warnings about potentially problematic code constructs.
	-Wextra: Enables additional warning flags, including warnings about non-standard or potentially error-prone code.
	-pedantic: Requests stricter conformance to the C standard and additional warnings about non-standard language features.
	-Werror: Treats all warnings as errors, causing the compilation to fail if any warnings are generated.

[5] #Set prefix path to tools that we use.
	"set(CMAKE_PREFIX_PATH some_path)
	set(BOOST_ROOT path_to_boost_lib)"

	for set(CMAKE_PREFIX_PATH some_path)
	In CMake, the set(CMAKE_PREFIX_PATH some_path) command is used to specify one or more paths where 
	CMake should look for package configuration files or CMake configuration files. These paths are 
	often used when you are working with external libraries or dependencies that are not installed in
	the default system locations, and you want CMake to find and use them during the configuration process.

	Here's how this command works:
	CMAKE_PREFIX_PATH: This is a CMake variable that you can set to a list of paths separated by semicolons (;).
	Each path in this list represents a directory where CMake should search for package configuration files 
	or CMake configuration files.

	some_path: Replace this with the actual path or paths where your external dependencies or packages are 
	installed or located.

	For example, suppose you have an external library called "MyLibrary" that is installed in the directory 
	/path/to/mylibrary. You can use the set(CMAKE_PREFIX_PATH ...) command to specify the path to this 
	library:
	set(CMAKE_PREFIX_PATH /path/to/mylibrary)

	If you have multiple paths to specify, you can separate them with semicolons:
	set(CMAKE_PREFIX_PATH
		/path/to/mylibrary
		/path/to/anotherlibrary
	)

	After setting CMAKE_PREFIX_PATH, CMake will search these paths for package or configuration files when
	you use commands like find_package() to locate external libraries. It helps CMake locate and configure
	dependencies correctly, ensuring that your project can build and link against them.

[6] adding library modules 
#Library modules go here.
"add_subdirectory(src)"

add_subdirectory(src):
This line instructs CMake to look for a CMakeLists.txt file in the src directory and process it. 
The src directory is typically where you place the source code for library modules.
The add_subdirectory command essentially includes and processes the CMake configuration for building the library 
modules located in the src directory. This allows you to build libraries as part of your project.

#Executable apps go here.
"add_subdirectory(apps)"

Similar to the previous line, this line instructs CMake to look for a CMakeLists.txt file in the apps directory and 
process it. The apps directory is typically where you place the source code for executable applications.
The add_subdirectory command includes and processes the CMake configuration for building the executable applications 
located in the apps directory.

Inside the src and apps directories, you would typically have separate CMake configuration files (CMakeLists.txt)
that define how to build the libraries and executables, respectively. These configuration files specify source files, 
compiler flags, dependencies, and other build-related settings for the components in their respective directories.

example:
project_root/
│
├── CMakeLists.txt
│
├── src/
│   ├── CMakeLists.txt (for library modules)
│   ├── library1.cpp
│   ├── library2.cpp
│   └── ...
│
├── apps/
│   ├── CMakeLists.txt (for executable apps)
│   ├── main_app1.cpp
│   ├── main_app2.cpp
│   └── ...
│
└── ...

The top-level CMakeLists.txt file in the project root typically sets project-wide settings, global dependencies, 
and additional project-level configurations.

By structuring your project this way, you can maintain a clean separation between library code and executable code 
and manage their build processes independently. Each directory (e.g., src and apps) can have its own build 
configuration tailored to the specific needs of its components.

In CMake, when the top-level CMakeLists.txt file includes add_subdirectory() commands to specify subdirectories, 
CMake will process the CMakeLists.txt files in those subdirectories first before continuing with the rest of the
configuration in the top-level CMakeLists.txt. The order of processing is top-down, meaning that CMake will
process subdirectories in the order they are specified.

Here's the typical flow:

When you run CMake on your project, it starts with the top-level CMakeLists.txt file.
If the top-level CMakeLists.txt includes add_subdirectory() commands, CMake will descend into those 
subdirectories and process their CMakeLists.txt files first.

Within each subdirectory, CMake will execute the configuration specified in the respective CMakeLists.txt file, 
which may involve defining targets, setting compiler flags, specifying source files, and so on.

After processing the subdirectory, CMake returns to the top-level CMakeLists.txt file and continues processing 
any remaining configuration instructions.

This order of processing is important because it allows you to set up dependencies and build components in the 
correct order. For example, if your project consists of libraries and executables, you might want to build 
libraries first so that executables can link against them.

[7] # Enable testing.
"if (CMAKE_PROJECT_NAME STREQUAL PROJECT_NAME)
	include(CTest)
endif()"

if (CMAKE_PROJECT_NAME STREQUAL PROJECT_NAME):
This line checks whether the value of the CMAKE_PROJECT_NAME variable is equal to the value of the PROJECT_NAME variable.
CMAKE_PROJECT_NAME is a built-in CMake variable that represents the name of the current project being configured.
PROJECT_NAME is a variable that is typically set by the project() command in the CMakeLists.txt file of the main project. 
It specifies the name of the project.

include(CTest):
If the condition in the if statement is true (i.e., the current project is the main project), this line includes support
for CTest. CTest is a CMake module that provides functionality for testing CMake-based projects. It includes commands 
and variables for defining and running tests, collecting test results, and generating test-related targets.

The purpose of this code is to enable CTest support when configuring the main project but not for subprojects or when 
the CMake configuration is included as a subproject in another CMake project. By doing so, you can enable testing 
specifically for the main project while excluding it for subprojects or nested projects.

Typically, you would include CTest support in the main project's CMakeLists.txt file so that you can define and run 
tests for your project. However, when your project is used as a subproject within another project, you may want to 
avoid enabling testing for the subproject, which is why this conditional check is useful.

[8] # Testing only available in this is the main app.
"if ((CMAKE_PROJECT_NAME STREQUAL PROJECT_NAME OR MODERN_CMAKE_BUILD_TESTING) AND BUILD_TESTING)
	set (MY_TESTCASES_DIR path_to_test_cases)
	add_subdirectory(tests)
endif()"

(CMAKE_PROJECT_NAME STREQUAL PROJECT_NAME OR MODERN_CMAKE_BUILD_TESTING): This condition checks two things:
Whether the value of CMAKE_PROJECT_NAME is equal to the value of PROJECT_NAME, which typically means the current 
project is the main project.
Whether the MODERN_CMAKE_BUILD_TESTING variable is set to a true value (e.g., ON).
If either of these conditions is true, it means that testing should be enabled for the project.
AND BUILD_TESTING: This condition checks whether the BUILD_TESTING option is enabled. The BUILD_TESTING option 
is a built-in CMake option that controls whether to build tests. If it is set to ON, tests will be built.

set (MY_TESTCASES_DIR path_to_test_cases): This line sets the MY_TESTCASES_DIR variable to the specified path
(path_to_test_cases). This variable is likely intended to store the directory where test cases are located.

add_subdirectory(tests): If all the conditions mentioned above are met, this line includes the tests subdirectory 
by using add_subdirectory. This typically means that the project is configured to build and run tests located 
in the tests subdirectory.

In summary, this code sets up conditions for enabling testing in a CMake project:
Testing is enabled if the project is the main project (CMAKE_PROJECT_NAME STREQUAL PROJECT_NAME), 
or if MODERN_CMAKE_BUILD_TESTING is set to ON, and BUILD_TESTING is also set to ON.
If testing is enabled, it specifies the directory where test cases are located (MY_TESTCASES_DIR) and 
includes the tests subdirectory for building and running tests.

src CMakeLists.txt file
-----------------------
[1] #list of dirs to build
"foreach(dir module1 module2)
	add_subdirectory(${dir})
endforeach()"

src module CMAKELists.txt file
------------------------------
[1] # Library name.
# In CMake, variables can store various types of data, 
# including strings, lists, and booleans. In this case, 
# lib_name is assigned a string value.
"set(lib_name some_library_name)"

[2] # Library sources.
# setting a variable with list of files
"set (
	 lib_srcs 
	 source_file1.C
	 source_file2.C
	 source_file3.C
	 source_file4.C	 
)"

[3] # Library header files.
# The file(GLOB ...) command in CMake is used to create a list of files that match a specified pattern. 
# In your provided line:
# It creates a list variable called lib_incs.
# It uses the file(GLOB ...) command to search for files in the directory specified by 
# "${PROJECT_SRC_DIR}/include/${lib_name}/" that match the pattern "*.h" (i.e., all files with a .h extension).
# The list of matching file paths is stored in the lib_incs variable.
# Typically, this kind of command is used when you want to collect a list of source files, header files, or 
# any other type of files in a specific directory that match a particular pattern. In this case, it's used 
# to collect header files (.h files) located in the ${PROJECT_SRC_DIR}/include/${lib_name}/ directory into the 
# lib_incs variable. You can then use this list of header files in other CMake commands or to set up your build
# targets, such as when specifying include directories for compiling source code.
"file(GLOB lib_incs "${PROJECT_SRC_DIR}/include/${lib_name}/*.h")"

[4] # Build library.
# You are defining and configuring a CMake target for a static library (${lib_name}) and specifying its public 
# header files.

# 1 This line adds a static library target named ${lib_name} (the value of the lib_name variable) to your CMake project.
# It specifies that the source files for the library are ${lib_srcs} (assuming ${lib_srcs} is a list of source file paths).
# This command essentially tells CMake to build a static library using the specified source files.
"add_library(${lib_name} STATIC ${lib_srcs})"

# 2 This line sets properties for the ${lib_name} target.
# Specifically, it sets the PUBLIC_HEADER property to "${lib_incs}", where ${lib_incs} is a list of header file paths 
# that you collected using the file(GLOB ...) command.
# The PUBLIC_HEADER property is used to specify the header files that should be installed when the library is installed. 
# It makes the header files part of the public interface of the library, allowing other projects to include and use them.
"set_targer_properties(${lib_name} PROPERTIES PUBLIC_HEADER "${lib_incs}")"

more explanation on this:
"public interface" refers to the parts of a library that are intended to be used by external projects or code that links 
to the library. The "public interface" defines what functions, classes, and symbols are accessible and usable by other code.

When you specify the PUBLIC_HEADER property for a library in CMake, you are essentially declaring that the header files 
included in the PUBLIC_HEADER property are part of the public interface of the library. This has several implications:
- Header Files Accessible to Users: Any code or project that links to your library can access and include these header files. 
Users of your library can include these headers in their own code to use the functions, classes, and types defined in 
those headers.
Header Files Installed with the Library: When you build and install your library, CMake ensures that the header files 
specified in the PUBLIC_HEADER property are also installed alongside the compiled library. This makes it convenient 
for users of your library to find and use the necessary header files.

- Documentation of Library Interface: By specifying which header files are part of the public interface, you are effectively 
documenting how others should use your library. It clarifies which parts of your library's API are intended to be stable 
and used by external code.

- Versioning and Compatibility: When you release updates to your library, you can manage the changes to the public interface. 
Keeping track of changes to public headers helps maintain backward compatibility for existing users of your library.

In summary, specifying the PUBLIC_HEADER property in CMake allows you to declare which header files are part of your 
library's public interface. These headers are meant to be used by external projects and code that link to your library, 
making it clear how your library should be used and helping users include the necessary headers in their own code.

[5] # Target include dirs.
Target_include_directories(
	$lib_name
	PUBLIC
	${CMAKE_CURRENT_SOURCE_DIR}
	${PROJECT_SOURCE_DIR}/include/${lib_name}
)

explaining: By using the target_include_directories command with the PUBLIC keyword, you ensure that ${CMAKE_CURRENT_SOURCE_DIR} 
and ${PROJECT_SOURCE_DIR}/include/${lib_name} are included in the include directories for ${lib_name} and any other targets that 
depend on it. This allows code outside the library to easily include the library's headers using #include <lib_name/header.h> notation, 
assuming ${lib_name} is the name of the library and header.h is one of its header files.

add_library vs add_subdirectory vs include()
--------------------------------------------
[1] add_library():
1 - Purpose: The add_library() command is used to define and configure CMake library targets. 
It specifies how source files are compiled into a library, such as a static library (e.g., .lib, .a) 
or a shared library (e.g., .dll, .so).

2 - Usage: You use add_library() to create a CMake target for a library, specify the source files, 
and set various properties related to the library target. It's typically used to build libraries 
that are part of your project.

what is "library target"? library target is a CMake object with a name encapsulates information about the library
In the context of CMake, a "library target" is not just a name; it represents a specific CMake 
construct that defines how a library should be built and used within a CMake-based project. 
When you create a library target using the add_library() command, you're defining a CMake object 
with a name, and this object encapsulates information about the library, its source files, and how 
it should be built and linked.

Here's what a library target consists of:
1 - Name: The name you provide to add_library() becomes the name of the library target.
This name is used to refer to the library target in other CMake commands and to link against 
the library in your build system.

2 - Source Files: You specify the source files that should be compiled to create the library. 
These are the source code files (e.g., .cpp, .c) that make up the library's implementation.

3 - Properties: You can set various properties for the library target, such as include directories, 
compile definitions, and compile options. These properties affect how the library is built and used.

4 - Linking: You can specify dependencies between targets. For example, if your library depends on 
another library, you can use the target_link_libraries() command to indicate this dependency.


what are types of libraries in add_library?
-------------------------------------------
1-Static Libraries:
Create a static library (also known as a "archive" library) using the STATIC keyword. 
Static libraries are linked at compile-time, and their code is physically included in the executable.
Example: add_library(my_static_lib STATIC source1.cpp source2.cpp)

2-Shared Libraries:
Create a shared library (also known as a "dynamic" or "shared object" library) using the SHARED keyword. 
Shared libraries are loaded at runtime and allow multiple programs to share the same code in memory.
Example: add_library(my_shared_lib SHARED source1.cpp source2.cpp)

3-Module Libraries:
Create a module library (also known as a "module" or "DLL" library) using the MODULE keyword. 
Module libraries are used in some build systems for specific purposes.
Example: add_library(my_module_lib MODULE source1.cpp source2.cpp)

4-Object Libraries:
Create an object library using the OBJECT keyword. Object libraries are not linked into an 
executable directly but are meant to be combined with other targets.
Example: add_library(my_object_lib OBJECT source1.cpp source2.cpp)

5-Interface Libraries:
Create an interface library using the INTERFACE keyword. Interface libraries do not produce 
any build artifacts but can be used to define properties, compile options, and dependencies
that are shared with other targets.
Example: add_library(my_interface_lib INTERFACE)

6-Header-Only Libraries:
You can use add_library() to create a target for header-only libraries, which do not have 
implementation files but provide header files that can be included in other projects.
Example: add_library(my_header_only_lib INTERFACE)

7-Custom Libraries:
You can create custom libraries by specifying custom build rules and source files as needed. 
These libraries might have unique requirements that don't fit into the standard categories 
mentioned above.

cmake -DCMAKE_BUILD_TYPE:STRING=DEBUG -DCMAKE_EXPORT_COMPILE_COMMANDS:BOOL=ON -G "Unix Makefiles" -S .. -B ./Debug
cmake -DCMAKE_BUILD_TYPE:STRING=RELEASE -DCMAKE_EXPORT_COMPILE_COMMANDS:BOOL=ON -G "Unix Makefiles" -S .. -B ./Debug
--------------------------------------------------------------------------------------------------------------------
The command you provided is a cmake command used to configure a CMake project with specific build options. 
Let's break down each part of the command:

cmake: This is the CMake command-line tool used to configure CMake projects.

-DCMAKE_BUILD_TYPE:STRING=DEBUG: This sets the CMake variable CMAKE_BUILD_TYPE to the value DEBUG. 
This specifies the build type as "DEBUG," which typically includes debug symbols and disables optimizations. 
Debug builds are useful for development and debugging.

-DCMAKE_EXPORT_COMPILE_COMMANDS:BOOL=ON: This sets the CMake variable CMAKE_EXPORT_COMPILE_COMMANDS to ON. 
When this option is enabled, CMake generates a JSON compile_commands.json file that contains information 
about the compiler commands used for building the project. This file can be useful for integrating with 
code editors, IDEs, and other development tools.

-G "Unix Makefiles": This specifies the CMake generator to use. In this case, you're using the "Unix Makefiles"
generator, which generates makefiles for building the project. Makefiles are commonly used on Unix-like systems
(Linux, macOS) for building projects.

-S ..: This sets the source directory for the CMake project to the parent directory (..). The source directory 
is where the CMakeLists.txt file is located.

-B ./Debug: This sets the build directory to ./Debug. The build directory is where the build artifacts 
(object files, executables, libraries) will be generated. By specifying ./Debug, you are configuring a build 
in a subdirectory called "Debug."

Overall, this cmake command configures the project for a debug build with the specified options, generator, 
source directory, and build directory. Once you run this command, you can typically proceed to build the 
project using the chosen generator (in this case, "Unix Makefiles") by running the appropriate build 
command (e.g., make on Unix-like systems).